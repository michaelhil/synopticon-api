<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaPipe Face Analysis Demo - 6DOF Tracking</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: #333;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .main-container {
            flex: 1;
            display: flex;
            gap: 20px;
            padding: 20px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        .video-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .video-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .video-wrapper {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 4/3;
        }

        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #overlay {
            pointer-events: none;
            z-index: 1;
        }

        .controls-section {
            width: 400px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .control-panel {
            position: relative;
        }

        .control-panel h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #667eea;
        }

        .help-icon {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .help-icon:hover {
            background: #764ba2;
            transform: scale(1.1);
        }

        .help-tooltip {
            position: absolute;
            top: 45px;
            right: 15px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.4;
            width: 280px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
        }

        .help-tooltip.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .help-tooltip::before {
            content: '';
            position: absolute;
            top: -6px;
            right: 20px;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 6px solid rgba(0, 0, 0, 0.9);
        }

        .pipeline-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .pipeline-option {
            display: flex;
            align-items: center;
            padding: 12px;
            border-radius: 8px;
            background: #f7f9fc;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .pipeline-option:hover {
            background: #eef2ff;
            border-color: #667eea;
        }

        .pipeline-option.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .pipeline-option input[type="radio"] {
            margin-right: 10px;
        }

        .pipeline-info {
            flex: 1;
        }

        .pipeline-name {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .pipeline-description {
            font-size: 12px;
            opacity: 0.8;
        }

        .strategy-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .strategy-btn {
            padding: 10px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .strategy-btn:hover {
            background: #f7f9fc;
        }

        .strategy-btn.active {
            background: #667eea;
            color: white;
        }

        .calibration-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .calibration-btn {
            padding: 12px;
            border: none;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .calibration-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .calibration-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .calibration-progress {
            height: 4px;
            background: #f0f0f0;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }

        .calibration-progress-bar {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .calibration-status {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }

        .pose-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        .pose-metric {
            text-align: center;
        }

        .pose-label {
            font-size: 12px;
            color: #999;
            margin-bottom: 5px;
        }

        .pose-value {
            font-size: 24px;
            font-weight: 600;
            color: #667eea;
        }

        .pose-unit {
            font-size: 14px;
            color: #999;
        }

        .performance-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .metric-item {
            display: flex;
            flex-direction: column;
        }

        .metric-label {
            font-size: 12px;
            color: #999;
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 18px;
            font-weight: 600;
            color: #333;
        }

        .comparison-chart {
            margin-top: 15px;
        }

        .chart-bar {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .chart-label {
            width: 80px;
            font-size: 12px;
            color: #666;
        }

        .chart-bar-container {
            flex: 1;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .chart-bar-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: width 0.5s ease;
        }

        .chart-value {
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 11px;
            color: white;
            font-weight: 600;
        }

        .visualization-3d {
            width: 100%;
            height: 300px;
            background: #000;
            border-radius: 8px;
            position: relative;
        }

        #pose3d {
            width: 100%;
            height: 100%;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
            animation: pulse 2s infinite;
        }

        .status-indicator.active {
            background: #4ade80;
        }

        .status-indicator.inactive {
            background: #ef4444;
            animation: none;
        }

        .status-indicator.processing {
            background: #fbbf24;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f0f0f0;
            border-top: 5px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        @keyframes fadeOut {
            from { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            to { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <p>Loading MediaPipe models...</p>
        </div>
    </div>

    <div class="header">
        <h1>MediaPipe Face Analysis - 6DOF Head Tracking</h1>
        <p>Advanced multi-pipeline face analysis with pose estimation and calibration</p>
    </div>

    <div class="main-container">
        <div class="video-section">
            <div class="video-container">
                <div class="video-wrapper">
                    <video id="video" autoplay playsinline></video>
                    <canvas id="overlay"></canvas>
                </div>
            </div>

            <div class="control-panel">
                <h2>6DOF Pose Estimation</h2>
                <div class="help-icon" onclick="toggleHelp('pose-display-help')">?</div>
                <div class="help-tooltip" id="pose-display-help">
                    <strong>6DOF Pose Estimation</strong><br>
                    Real-time head position and orientation tracking:<br>
                    • <strong>Rotation:</strong> Yaw (left/right), Pitch (up/down), Roll (tilt) in degrees<br>
                    • <strong>Translation:</strong> X (left/right), Y (up/down), Z (forward/back) in mm<br>
                    6DOF = Six Degrees of Freedom (3 rotation + 3 translation)
                </div>
                <div class="pose-display">
                    <div class="pose-metric">
                        <div class="pose-label">Yaw</div>
                        <div class="pose-value" id="yawValue">0</div>
                        <div class="pose-unit">°</div>
                    </div>
                    <div class="pose-metric">
                        <div class="pose-label">Pitch</div>
                        <div class="pose-value" id="pitchValue">0</div>
                        <div class="pose-unit">°</div>
                    </div>
                    <div class="pose-metric">
                        <div class="pose-label">Roll</div>
                        <div class="pose-value" id="rollValue">0</div>
                        <div class="pose-unit">°</div>
                    </div>
                    <div class="pose-metric">
                        <div class="pose-label">X</div>
                        <div class="pose-value" id="xValue">0</div>
                        <div class="pose-unit">mm</div>
                    </div>
                    <div class="pose-metric">
                        <div class="pose-label">Y</div>
                        <div class="pose-value" id="yValue">0</div>
                        <div class="pose-unit">mm</div>
                    </div>
                    <div class="pose-metric">
                        <div class="pose-label">Z</div>
                        <div class="pose-value" id="zValue">0</div>
                        <div class="pose-unit">mm</div>
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <h2>3D Visualization</h2>
                <div class="help-icon" onclick="toggleHelp('3d-viz-help')">?</div>
                <div class="help-tooltip" id="3d-viz-help">
                    <strong>3D Visualization</strong><br>
                    Real-time 3D representation of your head pose:<br>
                    • Shows head orientation in 3D space<br>
                    • Updates live with your head movements<br>
                    • Provides intuitive visualization of pose tracking accuracy<br>
                    • Uses Three.js for smooth 3D rendering
                </div>
                <div class="visualization-3d">
                    <canvas id="pose3d"></canvas>
                </div>
            </div>
        </div>

        <div class="controls-section">
            <div class="control-panel">
                <h2>Pipeline Selection</h2>
                <div class="help-icon" onclick="toggleHelp('pipeline-help')">?</div>
                <div class="help-tooltip" id="pipeline-help">
                    <strong>Pipeline Selection</strong><br>
                    Choose which AI model to use for face detection:<br>
                    • <strong>MediaPipe Face Mesh:</strong> 468 landmarks, high accuracy, 6DOF pose tracking<br>
                    • <strong>MediaPipe Iris:</strong> Eye tracking with gaze estimation and pupil detection<br>
                    • <strong>BlazeFace:</strong> Fast detection, basic 3DOF pose, good for performance
                </div>
                <div class="pipeline-selector" id="pipelineSelector">
                    <div class="pipeline-option" data-pipeline="mediapipe">
                        <input type="radio" name="pipeline" value="mediapipe">
                        <div class="pipeline-info">
                            <div class="pipeline-name">MediaPipe Face Mesh</div>
                            <div class="pipeline-description">468 landmarks, 6DOF pose, high accuracy</div>
                        </div>
                    </div>
                    <div class="pipeline-option active" data-pipeline="iris">
                        <input type="radio" name="pipeline" value="iris" checked>
                        <div class="pipeline-info">
                            <div class="pipeline-name">MediaPipe Iris</div>
                            <div class="pipeline-description">Eye tracking with gaze estimation</div>
                        </div>
                    </div>
                    <div class="pipeline-option" data-pipeline="blazeface">
                        <input type="radio" name="pipeline" value="blazeface">
                        <div class="pipeline-info">
                            <div class="pipeline-name">BlazeFace</div>
                            <div class="pipeline-description">Fast detection, 3DOF pose</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <h2>Processing Strategy</h2>
                <div class="help-icon" onclick="toggleHelp('strategy-help')">?</div>
                <div class="help-tooltip" id="strategy-help">
                    <strong>Processing Strategy</strong><br>
                    Choose how the system prioritizes performance vs accuracy:<br>
                    • <strong>Accuracy First:</strong> Best quality results, slower processing<br>
                    • <strong>Performance First:</strong> Fastest processing, basic quality<br>
                    • <strong>Hybrid:</strong> Balanced approach between speed and quality<br>
                    • <strong>Adaptive:</strong> Automatically adjusts based on system performance
                </div>
                <div class="strategy-selector">
                    <button class="strategy-btn active" data-strategy="accuracy_first">
                        Accuracy First
                    </button>
                    <button class="strategy-btn" data-strategy="performance_first">
                        Performance First
                    </button>
                    <button class="strategy-btn" data-strategy="hybrid">
                        Hybrid
                    </button>
                    <button class="strategy-btn" data-strategy="adaptive">
                        Adaptive
                    </button>
                </div>
            </div>

            <div class="control-panel">
                <h2>Pose Calibration</h2>
                <div class="help-icon" onclick="toggleHelp('pose-calibration-help')">?</div>
                <div class="help-tooltip" id="pose-calibration-help">
                    <strong>Pose Calibration</strong><br>
                    Calibrates head pose tracking for your personal facial structure:<br>
                    • <strong>Start Pose Calibration:</strong> Manual 3-second calibration - look straight ahead<br>
                    • <strong>Auto-Calibrate Pose:</strong> Automatic calibration over 3 seconds<br>
                    Calibration improves accuracy by establishing your neutral head position.
                </div>
                <div class="calibration-controls">
                    <button class="calibration-btn" id="calibrateBtn">
                        Start Pose Calibration
                    </button>
                    <button class="calibration-btn" id="autoCalibrateBtn">
                        Auto-Calibrate Pose
                    </button>
                    <div class="calibration-progress" id="calibrationProgress" style="display: none;">
                        <div class="calibration-progress-bar" id="calibrationBar"></div>
                    </div>
                    <div class="calibration-status" id="calibrationStatus">
                        <span class="status-indicator inactive"></span>
                        Not calibrated
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <h2>Eye Tracking Calibration</h2>
                <div class="help-icon" onclick="toggleHelp('eye-calibration-help')">?</div>
                <div class="help-tooltip" id="eye-calibration-help">
                    <strong>Eye Tracking Calibration</strong><br>
                    Calibrates gaze tracking for accurate eye movement detection:<br>
                    • <strong>Start Eye Calibration:</strong> Look at center dot while system collects 30 samples<br>
                    • <strong>Reset Eye Tracking:</strong> Clear calibration and restart<br>
                    Essential for accurate gaze vector tracking. Only works with Iris pipeline.
                </div>
                <div class="calibration-controls">
                    <button class="calibration-btn" id="eyeCalibrateBtn">
                        Start Eye Calibration
                    </button>
                    <button class="calibration-btn" id="eyeResetBtn">
                        Reset Eye Tracking
                    </button>
                    <div class="calibration-progress" id="eyeCalibrationProgress" style="display: none;">
                        <div class="calibration-progress-bar" id="eyeCalibrationBar"></div>
                    </div>
                    <div class="calibration-status" id="eyeCalibrationStatus">
                        <span class="status-indicator inactive"></span>
                        Eye tracking not calibrated
                    </div>
                    <div class="calibration-instructions" id="eyeCalibrationInstructions" style="display: none; font-size: 12px; margin-top: 10px; padding: 10px; background: #f7f9fc; border-radius: 6px; border-left: 3px solid #667eea;">
                        Look straight ahead and keep your eyes still during calibration
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <h2>Performance Metrics</h2>
                <div class="help-icon" onclick="toggleHelp('performance-help')">?</div>
                <div class="help-tooltip" id="performance-help">
                    <strong>Performance Metrics</strong><br>
                    Real-time performance monitoring:<br>
                    • <strong>FPS:</strong> Frames processed per second<br>
                    • <strong>Latency:</strong> Time to process each frame<br>
                    • <strong>Pipeline:</strong> Currently active detection model<br>
                    • <strong>Confidence:</strong> Detection quality score (0-100%)
                </div>
                <div class="performance-metrics">
                    <div class="metric-item">
                        <div class="metric-label">FPS</div>
                        <div class="metric-value" id="fpsValue">0</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">Latency</div>
                        <div class="metric-value" id="latencyValue">0ms</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">Pipeline</div>
                        <div class="metric-value" id="activePipeline">-</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">Confidence</div>
                        <div class="metric-value" id="confidenceValue">0%</div>
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <h2>Pipeline Comparison</h2>
                <div class="help-icon" onclick="toggleHelp('comparison-help')">?</div>
                <div class="help-tooltip" id="comparison-help">
                    <strong>Pipeline Comparison</strong><br>
                    Shows relative performance of different AI models:<br>
                    • Bar width represents processing time (shorter = faster)<br>
                    • Updated in real-time as you switch between pipelines<br>
                    • Helps you choose the best model for your needs
                </div>
                <div class="comparison-chart" id="comparisonChart">
                    <div class="chart-bar">
                        <div class="chart-label">MediaPipe</div>
                        <div class="chart-bar-container">
                            <div class="chart-bar-fill" id="mediapipeBar" style="width: 0%;">
                                <span class="chart-value">0 ms</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-bar">
                        <div class="chart-label">BlazeFace</div>
                        <div class="chart-bar-container">
                            <div class="chart-bar-fill" id="blazefaceBar" style="width: 0%;">
                                <span class="chart-value">0 ms</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-bar">
                        <div class="chart-label">Iris</div>
                        <div class="chart-bar-container">
                            <div class="chart-bar-fill" id="irisBar" style="width: 0%;">
                                <span class="chart-value">0 ms</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <h2>Display Options</h2>
                <div class="help-icon" onclick="toggleHelp('display-help')">?</div>
                <div class="help-tooltip" id="display-help">
                    <strong>Display Options</strong><br>
                    Control what information is shown on the video overlay:<br>
                    • <strong>Show Landmarks:</strong> Face detection points (468 for MediaPipe)<br>
                    • <strong>Show Pose Axes:</strong> 3D rotation indicators (red=X, green=Y, blue=Z)<br>
                    • <strong>Show Bounding Box:</strong> Rectangle around detected face<br>
                    • <strong>Show Eye Tracking:</strong> Gaze vectors and iris tracking<br>
                    • <strong>Gaze Trace Length:</strong> How long the eye movement trail lasts (0.5-10s)
                </div>
                <div class="toggle-switch">
                    <span>Show Landmarks</span>
                    <label class="switch">
                        <input type="checkbox" id="showLandmarks" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="toggle-switch">
                    <span>Show Pose Axes</span>
                    <label class="switch">
                        <input type="checkbox" id="showAxes" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="toggle-switch">
                    <span>Show Bounding Box</span>
                    <label class="switch">
                        <input type="checkbox" id="showBbox" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="toggle-switch">
                    <span>Show Eye Tracking</span>
                    <label class="switch">
                        <input type="checkbox" id="showEyes" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="trace-control" style="margin-top: 15px;">
                    <label for="traceLength" style="display: block; margin-bottom: 5px; font-size: 12px; color: #666;">
                        Gaze Trace Length: <span id="traceLengthValue">3.0s</span>
                    </label>
                    <input type="range" id="traceLength" min="0.5" max="10" step="0.5" value="3" style="width: 100%; margin-bottom: 5px;">
                </div>
            </div>
        </div>
    </div>

    <!-- Load MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script>
        // Debug MediaPipe loading
        window.addEventListener('load', () => {
            console.log('🔍 MediaPipe availability check:');
            console.log('  - window.FaceMesh:', typeof window.FaceMesh);
            console.log('  - window.Iris:', typeof window.Iris);
            console.log('  - window.Camera:', typeof window.Camera);
            console.log('  - MediaPipe objects:', Object.keys(window).filter(k => k.includes('Face') || k.includes('Iris') || k.includes('mediapipe')));
        });
    </script>
    
    <!-- Load Three.js for 3D visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Load application modules -->
    <script type="module">
        import { createAvailableProcessor } from './src/utils/direct-mediapipe.js';
        import { createPose3DVisualization } from './src/visualization/pose-3d.js';
        import { createPerformanceComparison } from './src/utils/mediapipe-integration.js';

        // Application state
        const state = {
            processor: null,
            comparison: null,
            pose3d: null,
            currentPipeline: 'iris',
            currentStrategy: 'accuracy_first',
            isCalibrating: false,
            autoCalibration: null,
            isEyeCalibrating: false,
            eyeCalibrationSamples: 0,
            gazeTrace: [],
            traceLength: 3000, // 3 seconds in milliseconds
            autoCalibrationComplete: false,
            // Smoothed values for display
            smoothedValues: {
                fps: 0,
                latency: 0,
                pose: {
                    yaw: 0, pitch: 0, roll: 0,
                    x: 0, y: 0, z: 0
                },
                confidence: 0
            },
            displayOptions: {
                showLandmarks: true,
                showAxes: true,
                showBbox: true,
                showEyes: true
            },
            performanceHistory: [],
            lastFrameTime: performance.now()
        };

        // Initialize application
        const initialize = async () => {
            const loadingOverlay = document.getElementById('loadingOverlay');
            loadingOverlay.style.display = 'flex';

            try {
                // Create direct processor (MediaPipe, BlazeFace, or Mock)
                state.processor = await createAvailableProcessor();
                
                // Initialize the processor
                const initialized = await state.processor.initialize();
                if (!initialized) {
                    throw new Error('Failed to initialize face detection');
                }

                // Create performance comparison
                state.comparison = createPerformanceComparison();

                // Initialize 3D pose visualization
                const canvas3d = document.getElementById('pose3d');
                state.pose3d = createPose3DVisualization(canvas3d);

                // Setup video stream
                await setupVideoStream();

                // Setup UI event handlers
                setupEventHandlers();

                // Initialize UI state to match app state
                initializeUIState();

                // Start processing loop
                requestAnimationFrame(processFrame);

                // Start automatic calibration sequence
                setTimeout(() => {
                    startAutoCalibrationSequence();
                }, 1000);

                loadingOverlay.style.display = 'none';
                console.log('✅ Application initialized successfully');

            } catch (error) {
                console.error('❌ Initialization failed:', error);
                loadingOverlay.style.display = 'none';
                
                // Show user-friendly error
                const errorMsg = error.message.includes('MediaPipe') ? 
                    'MediaPipe failed to load. Using fallback face detection.' :
                    'Failed to initialize: ' + error.message;
                    
                console.warn(errorMsg);
                
                // Try to continue with mock processor
                state.processor = createMockProcessor();
                await initialize();
            }
        };

        // Setup video stream
        const setupVideoStream = async () => {
            const video = document.getElementById('video');
            const overlay = document.getElementById('overlay');
            
            // Setup canvas overlay
            overlay.width = video.videoWidth || 640;
            overlay.height = video.videoHeight || 480;

            // Get user media
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'user'
                    }
                });

                video.srcObject = stream;
                
                // Wait for video to be ready
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        overlay.width = video.videoWidth;
                        overlay.height = video.videoHeight;
                        resolve();
                    };
                });

                console.log('Video stream ready:', video.videoWidth, 'x', video.videoHeight);

            } catch (error) {
                console.error('Failed to setup video stream:', error);
                throw error;
            }
        };

        // Main processing loop
        const processFrame = async () => {
            const video = document.getElementById('video');
            const overlay = document.getElementById('overlay');
            const ctx = overlay.getContext('2d');

            if (video.readyState === video.HAVE_ENOUGH_DATA && state.processor) {
                const startTime = performance.now();

                try {
                    // Process frame with direct processor
                    const result = await state.processor.processFrame(video);

                    if (result && result.faces && result.faces.length > 0) {
                        const face = result.faces[0];

                        // Update pose display
                        updatePoseDisplay(face.pose);

                        // Update 3D visualization
                        if (state.pose3d && face.pose) {
                            state.pose3d.updatePose(face.pose);
                        }

                        // Update gaze trace history
                        if (face.eyeTracking && face.eyeTracking.gazePoint && state.processor.isEyeCalibrated && state.processor.isEyeCalibrated()) {
                            updateGazeTrace(face.eyeTracking.gazePoint, overlay.width, overlay.height);
                        }

                        // Draw overlay
                        drawOverlay(ctx, face, overlay.width, overlay.height);

                        // Record performance metrics
                        const processingTime = performance.now() - startTime;
                        state.comparison.recordMetrics(result.pipelineUsed || state.currentPipeline, processingTime);

                        // Handle manual calibration sampling
                        if (state.isCalibrating && face.pose && state.processor.addCalibrationSample) {
                            const sampleResult = state.processor.addCalibrationSample(face.pose, face.landmarks);
                            if (sampleResult.progress) {
                                // Update progress bar
                                const progressBar = document.getElementById('calibrationBar');
                                if (progressBar) {
                                    progressBar.style.width = (sampleResult.progress * 100) + '%';
                                }
                            }
                        }

                        // Handle auto-calibration
                        if (state.autoCalibration && face.pose) {
                            const calibResult = state.autoCalibration.processAutoCalibrationFrame(face.pose, face.landmarks);
                            updateCalibrationStatus(calibResult);
                            
                            // Check if auto-calibration completed
                            if (calibResult.status === 'completed') {
                                console.log('🎯 Auto-calibration completed successfully');
                                state.autoCalibration = null; // Clear auto-calibration
                            } else if (calibResult.status === 'failed') {
                                console.log('❌ Auto-calibration failed:', calibResult.error);
                                state.autoCalibration = null; // Clear auto-calibration
                            }
                        }

                        // Handle eye tracking calibration sampling
                        if (state.isEyeCalibrating && face.eyeTracking && state.processor.addEyeCalibrationSample) {
                            const sampleResult = state.processor.addEyeCalibrationSample(face.eyeTracking);
                            if (sampleResult && sampleResult.samplesCollected !== undefined) {
                                state.eyeCalibrationSamples = sampleResult.samplesCollected;
                                updateEyeCalibrationProgress(sampleResult.progress || 0);
                                
                                // Update status display
                                updateEyeCalibrationStatus('collecting', sampleResult);
                                
                                // Auto-finish when enough samples collected
                                if (sampleResult.samplesCollected >= sampleResult.samplesRequired) {
                                    finishEyeCalibration();
                                }
                            }
                        }
                    } else {
                        // Clear overlay if no face detected
                        ctx.clearRect(0, 0, overlay.width, overlay.height);
                    }

                } catch (error) {
                    console.warn('Frame processing error:', error);
                }

                // Update performance metrics
                updatePerformanceMetrics();
            }

            requestAnimationFrame(processFrame);
        };

        // Draw overlay visualization
        const drawOverlay = (ctx, face, width, height) => {
            ctx.clearRect(0, 0, width, height);

            // Draw landmarks
            if (state.displayOptions.showLandmarks && face.landmarks) {
                ctx.fillStyle = '#667eea';
                face.landmarks.forEach(point => {
                    ctx.beginPath();
                    ctx.arc(point.x * width, point.y * height, 2, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }

            // Draw pose axes
            if (state.displayOptions.showAxes && face.pose) {
                drawPoseAxes(ctx, face.pose, width, height);
            }

            // Draw bounding box
            if (state.displayOptions.showBbox && face.boundingBox) {
                ctx.strokeStyle = '#764ba2';
                ctx.lineWidth = 2;
                ctx.strokeRect(
                    face.boundingBox.x * width,
                    face.boundingBox.y * height,
                    face.boundingBox.width * width,
                    face.boundingBox.height * height
                );
            }

            // Draw eye tracking
            if (state.displayOptions.showEyes && face.eyeTracking) {
                drawEyeTracking(ctx, face.eyeTracking, width, height);
            }

            // Draw calibration indicators
            if (state.isEyeCalibrating) {
                drawCalibrationOverlay(ctx, width, height);
            }
        };

        // Draw pose axes
        const drawPoseAxes = (ctx, pose, width, height) => {
            const centerX = width / 2;
            const centerY = height / 2;
            const axisLength = 100;

            // Calculate axis endpoints based on pose
            const yaw = pose.rotation.yaw || 0;
            const pitch = pose.rotation.pitch || 0;
            const roll = pose.rotation.roll || 0;

            // X-axis (red)
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + Math.cos(yaw) * axisLength,
                centerY + Math.sin(yaw) * axisLength * Math.sin(pitch)
            );
            ctx.stroke();

            // Y-axis (green)
            ctx.strokeStyle = '#00ff00';
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + Math.sin(roll) * axisLength,
                centerY - Math.cos(roll) * axisLength
            );
            ctx.stroke();

            // Z-axis (blue)
            ctx.strokeStyle = '#0000ff';
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + Math.sin(yaw) * axisLength,
                centerY + Math.cos(pitch) * axisLength
            );
            ctx.stroke();
        };

        // Draw eye tracking visualization
        const drawEyeTracking = (ctx, eyeTracking, width, height) => {
            // Draw gaze trace history first (behind current gaze vector)
            drawGazeTrace(ctx, width, height);
            // Draw iris centers
            if (eyeTracking.leftIris) {
                ctx.fillStyle = '#667eea';
                ctx.beginPath();
                ctx.arc(
                    eyeTracking.leftIris.center.x * width,
                    eyeTracking.leftIris.center.y * height,
                    8, 0, 2 * Math.PI
                );
                ctx.fill();
            }

            if (eyeTracking.rightIris) {
                ctx.fillStyle = '#764ba2';
                ctx.beginPath();
                ctx.arc(
                    eyeTracking.rightIris.center.x * width,
                    eyeTracking.rightIris.center.y * height,
                    8, 0, 2 * Math.PI
                );
                ctx.fill();
            }

            // Draw gaze vector using stored eye midpoint
            if (eyeTracking.eyeMidpoint && eyeTracking.gazePoint) {
                // Use stored eye midpoint for consistent positioning
                const startX = eyeTracking.eyeMidpoint.x * width;
                const startY = eyeTracking.eyeMidpoint.y * height;
                const endX = eyeTracking.gazePoint.x * width;
                const endY = eyeTracking.gazePoint.y * height;

                // Calculate vector length for dash sizing
                const vectorLength = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                const dashSize = Math.max(8, vectorLength / 15); // Adaptive dash size

                // Draw gaze vector with prominent styling
                ctx.strokeStyle = '#ff0066';
                ctx.lineWidth = 4;
                ctx.setLineDash([dashSize, dashSize * 0.6]);
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw start point (eye midpoint indicator)
                ctx.fillStyle = '#ff0066';
                ctx.beginPath();
                ctx.arc(startX, startY, 6, 0, 2 * Math.PI);
                ctx.fill();

                // Draw gaze target point with ring
                ctx.fillStyle = '#ff0066';
                ctx.beginPath();
                ctx.arc(endX, endY, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                // Outer ring
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(endX, endY, 10, 0, 2 * Math.PI);
                ctx.stroke();

                // Draw direction arrow at the end
                const angle = Math.atan2(endY - startY, endX - startX);
                const arrowSize = 12;
                
                ctx.fillStyle = '#ff0066';
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(
                    endX - arrowSize * Math.cos(angle - Math.PI / 6),
                    endY - arrowSize * Math.sin(angle - Math.PI / 6)
                );
                ctx.lineTo(
                    endX - arrowSize * Math.cos(angle + Math.PI / 6),
                    endY - arrowSize * Math.sin(angle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fill();
            }

            // Draw eye region outline for debugging
            if (eyeTracking.leftIris && eyeTracking.leftIris.landmarks) {
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                ctx.beginPath();
                eyeTracking.leftIris.landmarks.forEach((point, index) => {
                    const x = point.x * width;
                    const y = point.y * height;
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);
            }

            if (eyeTracking.rightIris && eyeTracking.rightIris.landmarks) {
                ctx.strokeStyle = '#764ba2';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                ctx.beginPath();
                eyeTracking.rightIris.landmarks.forEach((point, index) => {
                    const x = point.x * width;
                    const y = point.y * height;
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);
            }
        };

        // Update gaze trace history
        const updateGazeTrace = (gazePoint, canvasWidth, canvasHeight) => {
            const now = Date.now();
            const pixelPoint = {
                x: gazePoint.x * canvasWidth,
                y: gazePoint.y * canvasHeight,
                timestamp: now
            };
            
            // Add new point to trace
            state.gazeTrace.push(pixelPoint);
            
            // Remove old points beyond trace length
            const cutoff = now - state.traceLength;
            state.gazeTrace = state.gazeTrace.filter(point => point.timestamp > cutoff);
        };

        // Draw gaze trace history
        const drawGazeTrace = (ctx, width, height) => {
            if (state.gazeTrace.length < 2) return;
            
            const now = Date.now();
            const maxAge = state.traceLength;
            
            // Draw trace as connected line segments with fading opacity
            for (let i = 1; i < state.gazeTrace.length; i++) {
                const prevPoint = state.gazeTrace[i - 1];
                const currentPoint = state.gazeTrace[i];
                
                // Calculate age-based opacity (newer = more opaque)
                const age = now - currentPoint.timestamp;
                const opacity = Math.max(0, 1 - (age / maxAge));
                
                if (opacity <= 0) continue;
                
                // Draw line segment
                ctx.strokeStyle = `rgba(255, 165, 0, ${opacity * 0.8})`; // Orange trace
                ctx.lineWidth = Math.max(1, opacity * 3);
                ctx.beginPath();
                ctx.moveTo(prevPoint.x, prevPoint.y);
                ctx.lineTo(currentPoint.x, currentPoint.y);
                ctx.stroke();
                
                // Draw small dots at trace points for recent ones
                if (opacity > 0.3) {
                    ctx.fillStyle = `rgba(255, 165, 0, ${opacity})`;
                    ctx.beginPath();
                    ctx.arc(currentPoint.x, currentPoint.y, opacity * 2, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            // Draw the most recent point with a special highlight
            if (state.gazeTrace.length > 0) {
                const lastPoint = state.gazeTrace[state.gazeTrace.length - 1];
                const age = now - lastPoint.timestamp;
                if (age < 100) { // Only if very recent
                    ctx.fillStyle = 'rgba(255, 165, 0, 0.9)';
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(lastPoint.x, lastPoint.y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
            }
        };

        // Draw calibration overlay for visual feedback during eye calibration
        const drawCalibrationOverlay = (ctx, width, height) => {
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(102, 126, 234, 0.1)';
            ctx.fillRect(0, 0, width, height);

            // Center target circle for user to look at
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Pulsing animation based on time
            const pulseScale = 0.8 + 0.2 * Math.sin(Date.now() / 200);
            const radius = 30 * pulseScale;
            
            // Draw target circle with pulsing effect
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 4;
            ctx.fillStyle = 'rgba(102, 126, 234, 0.3)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            
            // Inner target dot
            ctx.fillStyle = '#667eea';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 6, 0, 2 * Math.PI);
            ctx.fill();
            
            // Progress indicator around the target
            const progressRadius = radius + 15;
            const progressAngle = (state.eyeCalibrationSamples / 30) * 2 * Math.PI;
            
            ctx.strokeStyle = '#764ba2';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.arc(centerX, centerY, progressRadius, -Math.PI / 2, -Math.PI / 2 + progressAngle);
            ctx.stroke();

            // Instruction text
            ctx.font = '18px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 4;
            
            const instructionText = 'Look at the center dot and keep your eyes still';
            const sampleText = `${state.eyeCalibrationSamples} / 30 samples collected`;
            
            // Text with outline for readability
            ctx.strokeText(instructionText, centerX, centerY - 80);
            ctx.fillText(instructionText, centerX, centerY - 80);
            
            ctx.font = '14px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.strokeText(sampleText, centerX, centerY + 80);
            ctx.fillText(sampleText, centerX, centerY + 80);
            
            ctx.textAlign = 'start'; // Reset text alignment
        };

        // Smooth values using exponential moving average
        const smoothValue = (current, target, alpha = 0.1) => {
            return current + alpha * (target - current);
        };

        // Update pose display with smoothing
        const updatePoseDisplay = (pose) => {
            if (!pose) return;

            // Convert radians to degrees
            const toDegrees = (rad) => rad * 180 / Math.PI;

            // Smooth the pose values
            const smoothingFactor = 0.15; // Lower = smoother, higher = more responsive
            
            // Update smoothed rotation values
            state.smoothedValues.pose.yaw = smoothValue(state.smoothedValues.pose.yaw, toDegrees(pose.rotation?.yaw || 0), smoothingFactor);
            state.smoothedValues.pose.pitch = smoothValue(state.smoothedValues.pose.pitch, toDegrees(pose.rotation?.pitch || 0), smoothingFactor);
            state.smoothedValues.pose.roll = smoothValue(state.smoothedValues.pose.roll, toDegrees(pose.rotation?.roll || 0), smoothingFactor);

            // Update smoothed translation values
            if (pose.translation) {
                state.smoothedValues.pose.x = smoothValue(state.smoothedValues.pose.x, pose.translation.x || 0, smoothingFactor);
                state.smoothedValues.pose.y = smoothValue(state.smoothedValues.pose.y, pose.translation.y || 0, smoothingFactor);
                state.smoothedValues.pose.z = smoothValue(state.smoothedValues.pose.z, pose.translation.z || 0, smoothingFactor);
            }

            // Update smoothed confidence
            const targetConfidence = (pose.confidence || 0) * 100;
            state.smoothedValues.confidence = smoothValue(state.smoothedValues.confidence, targetConfidence, smoothingFactor);

            // Update display with smoothed values (only update every few frames to reduce flicker)
            if (Math.random() < 0.2) { // Update 20% of frames
                document.getElementById('yawValue').textContent = state.smoothedValues.pose.yaw.toFixed(1);
                document.getElementById('pitchValue').textContent = state.smoothedValues.pose.pitch.toFixed(1);
                document.getElementById('rollValue').textContent = state.smoothedValues.pose.roll.toFixed(1);

                if (pose.translation) {
                    document.getElementById('xValue').textContent = state.smoothedValues.pose.x.toFixed(1);
                    document.getElementById('yValue').textContent = state.smoothedValues.pose.y.toFixed(1);
                    document.getElementById('zValue').textContent = state.smoothedValues.pose.z.toFixed(1);
                }

                document.getElementById('confidenceValue').textContent = state.smoothedValues.confidence.toFixed(0) + '%';
            }
        };

        // Update performance metrics with smoothing
        const updatePerformanceMetrics = () => {
            const now = performance.now();
            const deltaTime = now - state.lastFrameTime;
            state.lastFrameTime = now;

            // Calculate and smooth FPS
            const targetFps = 1000 / deltaTime;
            state.smoothedValues.fps = smoothValue(state.smoothedValues.fps, targetFps, 0.1);

            // Smooth latency
            state.smoothedValues.latency = smoothValue(state.smoothedValues.latency, deltaTime, 0.1);

            // Update display less frequently to reduce flicker
            if (Math.random() < 0.3) { // Update 30% of frames
                document.getElementById('fpsValue').textContent = Math.round(state.smoothedValues.fps);
                document.getElementById('latencyValue').textContent = state.smoothedValues.latency.toFixed(1) + 'ms';
                document.getElementById('activePipeline').textContent = state.currentPipeline;
            }

            // Update comparison chart (less frequently)
            if (Math.random() < 0.1) { // Update 10% of frames
                const comparison = state.comparison.getComparison();
                updateComparisonChart(comparison);
            }
        };

        // Update comparison chart
        const updateComparisonChart = (comparison) => {
            const maxTime = 50; // Max time for chart scale (ms)

            Object.keys(comparison).forEach(pipeline => {
                const data = comparison[pipeline];
                const barElement = document.getElementById(pipeline + 'Bar');
                if (barElement) {
                    const percentage = Math.min(100, (data.averageTime / maxTime) * 100);
                    barElement.style.width = percentage + '%';
                    barElement.querySelector('.chart-value').textContent = data.averageTime.toFixed(1) + ' ms';
                }
            });
        };

        // Update calibration status
        const updateCalibrationStatus = (result) => {
            const statusElement = document.getElementById('calibrationStatus');
            const progressBar = document.getElementById('calibrationBar');
            const progressContainer = document.getElementById('calibrationProgress');

            if (result.status === 'collecting') {
                progressContainer.style.display = 'block';
                progressBar.style.width = (result.progress * 100) + '%';
                statusElement.innerHTML = `<span class="status-indicator processing"></span>Calibrating... ${result.samples} samples`;
            } else if (result.status === 'completed') {
                progressContainer.style.display = 'none';
                statusElement.innerHTML = `<span class="status-indicator active"></span>Calibrated (${result.quality?.rating || 'good'})`;
                state.autoCalibration = null;
            } else if (result.status === 'failed') {
                progressContainer.style.display = 'none';
                statusElement.innerHTML = `<span class="status-indicator inactive"></span>Calibration failed: ${result.error}`;
                state.autoCalibration = null;
            }
        };

        // Initialize UI state to match application state
        const initializeUIState = () => {
            // Set pipeline selection
            selectPipeline(state.currentPipeline);
            
            // Set strategy selection  
            selectStrategy(state.currentStrategy);
            
            // Set display options
            document.getElementById('showLandmarks').checked = state.displayOptions.showLandmarks;
            document.getElementById('showAxes').checked = state.displayOptions.showAxes;
            document.getElementById('showBbox').checked = state.displayOptions.showBbox;
            document.getElementById('showEyes').checked = state.displayOptions.showEyes;
            
            console.log('🎛️ UI state initialized:', {
                pipeline: state.currentPipeline,
                strategy: state.currentStrategy,
                displayOptions: state.displayOptions
            });
        };

        // Setup event handlers
        const setupEventHandlers = () => {
            // Pipeline selection
            document.querySelectorAll('.pipeline-option').forEach(option => {
                option.addEventListener('click', () => {
                    const pipeline = option.dataset.pipeline;
                    selectPipeline(pipeline);
                });
            });

            // Strategy selection
            document.querySelectorAll('.strategy-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const strategy = btn.dataset.strategy;
                    selectStrategy(strategy);
                });
            });

            // Calibration buttons
            document.getElementById('calibrateBtn').addEventListener('click', startCalibration);
            document.getElementById('autoCalibrateBtn').addEventListener('click', startAutoCalibration);
            
            // Eye tracking calibration buttons
            document.getElementById('eyeCalibrateBtn').addEventListener('click', startEyeCalibration);
            document.getElementById('eyeResetBtn').addEventListener('click', resetEyeTracking);

            // Display toggles
            document.getElementById('showLandmarks').addEventListener('change', (e) => {
                state.displayOptions.showLandmarks = e.target.checked;
            });

            document.getElementById('showAxes').addEventListener('change', (e) => {
                state.displayOptions.showAxes = e.target.checked;
            });

            document.getElementById('showBbox').addEventListener('change', (e) => {
                state.displayOptions.showBbox = e.target.checked;
            });

            document.getElementById('showEyes').addEventListener('change', (e) => {
                state.displayOptions.showEyes = e.target.checked;
            });

            // Trace length control
            document.getElementById('traceLength').addEventListener('input', (e) => {
                state.traceLength = parseFloat(e.target.value) * 1000; // Convert to milliseconds
                document.getElementById('traceLengthValue').textContent = e.target.value + 's';
                // Clear existing trace when changing length
                state.gazeTrace = [];
            });
        };

        // Select pipeline
        const selectPipeline = (pipeline) => {
            // Update UI
            document.querySelectorAll('.pipeline-option').forEach(option => {
                option.classList.toggle('active', option.dataset.pipeline === pipeline);
            });

            // Update radio button
            document.querySelector(`input[value="${pipeline}"]`).checked = true;

            // Switch processor pipeline
            if (state.processor && state.processor.switchPipeline) {
                const switched = state.processor.switchPipeline(pipeline);
                if (switched) {
                    state.currentPipeline = pipeline;
                    console.log('✅ Switched to pipeline:', pipeline);
                } else {
                    console.warn('❌ Failed to switch to pipeline:', pipeline);
                    // Reset UI to current pipeline
                    document.querySelector(`input[value="${state.currentPipeline}"]`).checked = true;
                    document.querySelector(`[data-pipeline="${state.currentPipeline}"]`).classList.add('active');
                    document.querySelector(`[data-pipeline="${pipeline}"]`).classList.remove('active');
                }
            } else {
                state.currentPipeline = pipeline;
                console.log('Selected pipeline:', pipeline);
            }
        };

        // Select strategy
        const selectStrategy = (strategy) => {
            // Update UI
            document.querySelectorAll('.strategy-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.strategy === strategy);
            });

            // Update processor
            if (state.processor && state.processor.switchStrategy) {
                state.processor.switchStrategy(strategy);
            }

            // Update state
            state.currentStrategy = strategy;

            console.log('Selected strategy:', strategy);
        };

        // Automatic calibration sequence on startup
        const startAutoCalibrationSequence = async () => {
            console.log('🤖 Starting automatic calibration sequence...');
            
            // Wait a moment for everything to be ready
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // First do pose auto-calibration using the proper auto-calibration method
            if (state.processor && !state.processor.isCalibrated() && !state.isCalibrating) {
                console.log('🎯 Starting automatic pose calibration...');
                
                // Use the built-in auto-calibration instead of manual calibration
                if (state.processor.setupAutoCalibration) {
                    try {
                        state.autoCalibration = state.processor.setupAutoCalibration();
                        
                        // Show user message
                        showAutoCalibrationMessage('Pose Calibration', 'Please look straight ahead for automatic calibration', 4000);
                        
                        // Wait for pose calibration to complete or timeout
                        await waitForCalibration('pose', 8000);
                    } catch (error) {
                        console.warn('Auto-calibration setup failed:', error.message);
                        state.autoCalibration = null;
                    }
                }
            }
            
            // Then do eye tracking calibration if on iris pipeline
            if (state.currentPipeline === 'iris' && state.processor && !state.processor.isEyeCalibrated()) {
                console.log('👁️ Starting automatic eye calibration...');
                setTimeout(() => {
                    startAutoEyeCalibration();
                }, 2000); // Give user time to see the first calibration completed
            }
            
            state.autoCalibrationComplete = true;
            console.log('✅ Automatic calibration sequence complete');
        };

        // Wait for calibration to complete
        const waitForCalibration = (type, timeout) => {
            return new Promise((resolve) => {
                const startTime = Date.now();
                let lastLogTime = 0;
                
                const checkCalibration = () => {
                    const elapsed = Date.now() - startTime;
                    
                    // Log progress occasionally
                    if (elapsed - lastLogTime > 1000) {
                        console.log(`⏱️ Waiting for ${type} calibration... ${(elapsed/1000).toFixed(1)}s`);
                        lastLogTime = elapsed;
                    }
                    
                    if (type === 'pose' && state.processor?.isCalibrated?.()) {
                        console.log(`✅ ${type} calibration completed after ${(elapsed/1000).toFixed(1)}s`);
                        resolve(true);
                    } else if (type === 'eye' && state.processor?.isEyeCalibrated?.()) {
                        console.log(`✅ ${type} calibration completed after ${(elapsed/1000).toFixed(1)}s`);
                        resolve(true);
                    } else if (elapsed > timeout) {
                        console.log(`⏱️ ${type} calibration timeout after ${(elapsed/1000).toFixed(1)}s`);
                        state.autoCalibration = null; // Clear auto-calibration on timeout
                        resolve(false);
                    } else {
                        setTimeout(checkCalibration, 200);
                    }
                };
                checkCalibration();
            });
        };

        // Automatic eye calibration
        const startAutoEyeCalibration = () => {
            if (!state.processor || state.isEyeCalibrating) return;
            
            console.log('👁️ Auto eye calibration: Please look at the center of the screen');
            startEyeCalibrationProcess();
            
            // Show user instruction
            showAutoCalibrationMessage('Eye Calibration', 'Look at the center dot and keep your eyes still', 5000);
        };

        // Show auto-calibration message overlay
        const showAutoCalibrationMessage = (title, message, duration) => {
            // Create temporary message overlay
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(102, 126, 234, 0.95);
                color: white;
                padding: 20px 30px;
                border-radius: 12px;
                font-family: -apple-system, BlinkMacSystemFont, sans-serif;
                font-size: 16px;
                text-align: center;
                z-index: 1001;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                animation: fadeIn 0.3s ease;
            `;
            
            messageDiv.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 8px;">${title}</div>
                <div style="font-size: 14px; opacity: 0.9;">${message}</div>
            `;
            
            document.body.appendChild(messageDiv);
            
            // Remove after duration
            setTimeout(() => {
                messageDiv.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        document.body.removeChild(messageDiv);
                    }
                }, 300);
            }, duration);
        };

        // Start manual calibration
        const startCalibration = () => {
            if (state.isCalibrating || !state.processor || state.autoCalibration) {
                console.log('Cannot start manual calibration: already calibrating or auto-calibration in progress');
                return;
            }

            state.isCalibrating = true;
            const result = state.processor.startCalibration();

            document.getElementById('calibrateBtn').textContent = 'Calibrating...';
            document.getElementById('calibrateBtn').disabled = true;

            // Show progress
            document.getElementById('calibrationProgress').style.display = 'block';

            // Auto-finish after duration
            setTimeout(() => {
                try {
                    if (state.isCalibrating && state.processor.finishCalibration) {
                        const finalResult = state.processor.finishCalibration();
                        updateCalibrationStatus({ status: 'completed', ...finalResult });
                    } else {
                        updateCalibrationStatus({ status: 'failed', error: 'Calibration was interrupted' });
                    }
                } catch (error) {
                    console.warn('Calibration finish error:', error.message);
                    updateCalibrationStatus({ status: 'failed', error: error.message });
                }

                document.getElementById('calibrateBtn').textContent = 'Start Calibration';
                document.getElementById('calibrateBtn').disabled = false;
                state.isCalibrating = false;
            }, result.duration);
        };

        // Start manual auto-calibration (different from startup auto-calibration)
        const startAutoCalibration = () => {
            if (state.autoCalibration || !state.processor) return;

            console.log('🤖 Starting manual auto-calibration...');
            state.autoCalibration = state.processor.setupAutoCalibration();
            
            document.getElementById('autoCalibrateBtn').textContent = 'Auto-calibrating...';
            document.getElementById('autoCalibrateBtn').disabled = true;

            // Reset button after timeout
            setTimeout(() => {
                if (!state.processor.isCalibrated()) {
                    // If calibration didn't complete, reset
                    state.autoCalibration = null;
                }
                document.getElementById('autoCalibrateBtn').textContent = 'Auto-Calibrate Pose';
                document.getElementById('autoCalibrateBtn').disabled = false;
            }, 8000);
        };

        // Start eye tracking calibration
        const startEyeCalibration = () => {
            if (state.isEyeCalibrating || !state.processor || !state.processor.startEyeCalibration) {
                console.warn('Eye calibration not available or already in progress');
                return;
            }

            // Switch to iris pipeline if not already selected
            if (state.currentPipeline !== 'iris') {
                selectPipeline('iris');
                // Give some time for pipeline to switch
                setTimeout(() => startEyeCalibrationProcess(), 500);
            } else {
                startEyeCalibrationProcess();
            }
        };

        const startEyeCalibrationProcess = () => {
            state.isEyeCalibrating = true;
            state.eyeCalibrationSamples = 0;
            
            const result = state.processor.startEyeCalibration();
            
            // Update UI
            document.getElementById('eyeCalibrateBtn').textContent = 'Calibrating Eyes...';
            document.getElementById('eyeCalibrateBtn').disabled = true;
            document.getElementById('eyeCalibrationProgress').style.display = 'block';
            document.getElementById('eyeCalibrationInstructions').style.display = 'block';
            
            // Update status
            updateEyeCalibrationStatus('collecting', result);
            
            console.log('Eye calibration started:', result);
        };

        // Finish eye tracking calibration
        const finishEyeCalibration = () => {
            if (!state.isEyeCalibrating || !state.processor.finishEyeCalibration) return;
            
            try {
                const result = state.processor.finishEyeCalibration();
                updateEyeCalibrationStatus('completed', result);
                console.log('Eye calibration completed:', result);
            } catch (error) {
                updateEyeCalibrationStatus('failed', { error: error.message });
                console.error('Eye calibration failed:', error);
            }
            
            // Reset UI
            state.isEyeCalibrating = false;
            document.getElementById('eyeCalibrateBtn').textContent = 'Start Eye Calibration';
            document.getElementById('eyeCalibrateBtn').disabled = false;
            document.getElementById('eyeCalibrationProgress').style.display = 'none';
            document.getElementById('eyeCalibrationInstructions').style.display = 'none';
        };

        // Reset eye tracking
        const resetEyeTracking = () => {
            if (!state.processor || !state.processor.resetEyeCalibration) {
                console.warn('Eye calibration reset not available');
                return;
            }
            
            state.processor.resetEyeCalibration();
            state.isEyeCalibrating = false;
            state.eyeCalibrationSamples = 0;
            
            // Reset UI
            document.getElementById('eyeCalibrateBtn').textContent = 'Start Eye Calibration';
            document.getElementById('eyeCalibrateBtn').disabled = false;
            document.getElementById('eyeCalibrationProgress').style.display = 'none';
            document.getElementById('eyeCalibrationInstructions').style.display = 'none';
            
            updateEyeCalibrationStatus('reset');
            console.log('Eye calibration reset');
        };

        // Update eye calibration progress
        const updateEyeCalibrationProgress = (progress) => {
            const progressBar = document.getElementById('eyeCalibrationBar');
            if (progressBar) {
                progressBar.style.width = (progress * 100) + '%';
            }
        };

        // Update eye calibration status
        const updateEyeCalibrationStatus = (status, result = null) => {
            const statusElement = document.getElementById('eyeCalibrationStatus');
            
            switch (status) {
                case 'collecting':
                    statusElement.innerHTML = `<span class="status-indicator processing"></span>Collecting eye samples... (${state.eyeCalibrationSamples}/${result?.sampleCount || 30})`;
                    break;
                case 'completed':
                    statusElement.innerHTML = `<span class="status-indicator active"></span>Eye tracking calibrated (${result?.samplesUsed || state.eyeCalibrationSamples} samples)`;
                    break;
                case 'failed':
                    statusElement.innerHTML = `<span class="status-indicator inactive"></span>Eye calibration failed: ${result?.error || 'Unknown error'}`;
                    break;
                case 'reset':
                default:
                    statusElement.innerHTML = `<span class="status-indicator inactive"></span>Eye tracking not calibrated`;
                    break;
            }
        };

        // Mock processor for fallback
        const createMockProcessor = () => ({
            initialize: async () => true,
            processFrame: async () => ({
                faces: [{
                    landmarks: [],
                    pose: {
                        rotation: { 
                            yaw: (Math.random() - 0.5) * 0.5, 
                            pitch: (Math.random() - 0.5) * 0.3, 
                            roll: (Math.random() - 0.5) * 0.2 
                        },
                        translation: { 
                            x: (Math.random() - 0.5) * 50, 
                            y: (Math.random() - 0.5) * 30, 
                            z: (Math.random() - 0.5) * 20 
                        },
                        confidence: 0.8 + Math.random() * 0.2
                    },
                    boundingBox: { x: 0.25, y: 0.25, width: 0.5, height: 0.5 },
                    confidence: 0.8 + Math.random() * 0.2
                }],
                pipelineUsed: 'mock',
                processingTime: 10 + Math.random() * 5
            }),
            startCalibration: () => ({ duration: 3000, requiredSamples: 30 }),
            finishCalibration: () => ({ success: true, quality: { rating: 'good' } }),
            setupAutoCalibration: () => ({
                processAutoCalibrationFrame: () => ({ status: 'waiting', reason: 'mock' })
            }),
            switchStrategy: () => {},
            isCalibrated: () => false,
            isInitialized: () => true
        });

        // Toggle help tooltips
        window.toggleHelp = (helpId) => {
            // Hide all other tooltips first
            document.querySelectorAll('.help-tooltip').forEach(tooltip => {
                if (tooltip.id !== helpId) {
                    tooltip.classList.remove('visible');
                }
            });
            
            // Toggle the clicked tooltip
            const tooltip = document.getElementById(helpId);
            if (tooltip) {
                tooltip.classList.toggle('visible');
            }
        };

        // Hide tooltips when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.classList.contains('help-icon')) {
                document.querySelectorAll('.help-tooltip.visible').forEach(tooltip => {
                    tooltip.classList.remove('visible');
                });
            }
        });

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>