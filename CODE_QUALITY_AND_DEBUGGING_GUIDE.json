{
  "metadata": {
    "purpose": "Prevent recurring bug patterns through systematic analysis and prevention strategies",
    "scope": "All future development in this codebase and similar projects",
    "lastUpdated": "2025-08-23",
    "version": "1.0.0"
  },
  "bugCategories": {
    "contextScope": {
      "name": "Context & Scope Issues",
      "percentage": 35,
      "priority": "high",
      "bugTypes": {
        "variableScopeViolations": {
          "examples": [
            "getGL is not defined - Function defined in outer scope, called from inner closure",
            "state.gl references in functions that don't have state access",
            "Module-level variables not accessible in nested functions"
          ],
          "rootCauses": [
            "JavaScript closure misunderstanding",
            "Function factories with improper scope chain",
            "Dynamic function creation without proper context binding"
          ],
          "detectionPattern": "function.*\\{[\\s\\S]*?\\b(\\w+)\\b\\([\\s\\S]*?\\}[\\s\\S]*?return[\\s\\S]*?\\{[\\s\\S]*?\\b\\1\\b",
          "dangerousPattern": "const createModule = () => {\n  const helper = () => { /* defined here */ };\n  \n  const nestedFunction = () => {\n    helper(); // May not be in scope when called dynamically\n  };\n  \n  return { process: nestedFunction }; // Closure broken\n};",
          "safePattern": "const createModule = () => {\n  const helper = () => { /* defined here */ };\n  \n  const nestedFunction = () => {\n    helper(); // Direct reference in same closure\n  };\n  \n  return { \n    process: nestedFunction,\n    helper // Explicitly expose if needed externally\n  };\n};"
        },
        "contextLossAsync": {
          "examples": [
            "this context lost in Promise chains",
            "State mutations in async callbacks affecting wrong instance",
            "Race conditions between initialization and usage"
          ],
          "dangerousPattern": "class Module {\n  async process() {\n    await something.then(this.callback); // Context lost\n  }\n}",
          "safePattern": "const createModule = () => {\n  const state = { /* local state */ };\n  \n  const process = async () => {\n    await something.then(result => callback(result)); // Arrow function preserves context\n  };\n  \n  return { process };\n};"
        }
      }
    },
    "webglContext": {
      "name": "WebGL Context Management",
      "percentage": 25,
      "priority": "high",
      "bugTypes": {
        "contextAvailabilityTiming": {
          "examples": [
            "gl.getExtension is not a function - WebGL context not fully initialized",
            "Context access before engine initialization",
            "Mock context objects missing required methods"
          ],
          "rootCauses": [
            "Initialization order dependencies",
            "Sync/async initialization mismatches",
            "Environment differences (browser vs server)"
          ],
          "detectionPattern": "\\.gl[\\.].*(?!if|try|validateContext)",
          "validationPattern": "const validateWebGLContext = (gl) => {\n  if (!gl) throw new Error('WebGL context is null');\n  if (typeof gl.getExtension !== 'function') throw new Error('Invalid WebGL context mock');\n  if (gl.isContextLost && gl.isContextLost()) throw new Error('WebGL context lost');\n  return true;\n};",
          "safeAccessPattern": "const getWebGLContext = () => {\n  if (!state.engine?.gl) throw new Error('WebGL engine not initialized');\n  validateWebGLContext(state.engine.gl);\n  return state.engine.gl;\n};"
        },
        "platformEnvironmentMismatches": {
          "examples": [
            "Server-side canvas mocks missing WebGL methods",
            "Browser-only APIs called on server",
            "Node.js vs browser import differences"
          ],
          "safePattern": "const isNode = typeof window === 'undefined';\nconst isBrowser = typeof window !== 'undefined';\n\nconst createCanvas = (width, height) => {\n  if (isBrowser) {\n    return document.createElement('canvas');\n  } else {\n    return createMockCanvas(width, height); // Proper server mock\n  }\n};"
        }
      }
    },
    "importExportDependencies": {
      "name": "Import/Export Dependencies",
      "percentage": 20,
      "priority": "medium",
      "bugTypes": {
        "circularDependencies": {
          "examples": [
            "Module A imports Module B, which imports Module A",
            "Index files creating circular reference chains",
            "Barrel export conflicts"
          ],
          "detectionPattern": "import.*from.*\\/.*(?=[\\s\\S]*export.*import.*from.*\\/)",
          "dangerousPattern": "// file1.js\nimport { helper } from './file2.js';\nexport const main = () => helper();\n\n// file2.js  \nimport { main } from './file1.js';  // CIRCULAR!\nexport const helper = () => main();",
          "safePattern": "// Use dependency injection instead\nexport const createModule = (dependencies) => {\n  const { helper } = dependencies;\n  return { main: () => helper() };\n};"
        },
        "missingExportImportMismatches": {
          "examples": [
            "Named exports imported as default exports",
            "Functions renamed but imports not updated",
            "Module path changes breaking references"
          ],
          "safePatterns": [
            "export const createFunction = () => { /* */ };           // Named export",
            "export { createFunction as default };                    // Explicit default",
            "export { createFunction, helperFunction };               // Multiple named"
          ]
        }
      }
    },
    "errorHandlingRecursion": {
      "name": "Error Handling Recursion",
      "percentage": 10,
      "priority": "medium",
      "bugTypes": {
        "infiniteErrorLoops": {
          "examples": [
            "Error handler calling itself recursively",
            "Recovery mechanisms triggering the same error",
            "Stack overflow from error processing"
          ],
          "detectionPattern": "handleError[\\s\\S]*?catch[\\s\\S]*?handleError",
          "dangerousPattern": "const handleError = (error) => {\n  try {\n    logError(error); // This might fail and call handleError again!\n  } catch (loggingError) {\n    handleError(loggingError); // INFINITE RECURSION\n  }\n};",
          "safePattern": "const handleError = (error, depth = 0) => {\n  if (depth > 3) {\n    console.error('Error handling failed, giving up:', error);\n    return;\n  }\n  \n  try {\n    logError(error);\n  } catch (loggingError) {\n    handleError(loggingError, depth + 1); // Limited recursion\n  }\n};"
        }
      }
    },
    "framebufferResourceManagement": {
      "name": "Framebuffer/Resource Management",
      "percentage": 10,
      "priority": "medium",
      "bugTypes": {
        "webglResourceStateIssues": {
          "examples": [
            "Framebuffer not complete due to wrong texture format",
            "Resources not properly bound before use",
            "Memory leaks from uncleaned resources"
          ],
          "detectionPattern": "create(?:Framebuffer|Texture|Buffer).*(?!delete)",
          "safePattern": "const createFramebuffer = (gl, width, height) => {\n  const framebuffer = gl.createFramebuffer();\n  const texture = createCompatibleTexture(gl, width, height);\n  \n  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n  \n  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n  if (status !== gl.FRAMEBUFFER_COMPLETE) {\n    gl.deleteFramebuffer(framebuffer);\n    gl.deleteTexture(texture);\n    throw new Error(`Framebuffer not complete: ${getFramebufferStatusName(status)}`);\n  }\n  \n  return { framebuffer, texture, cleanup: () => {\n    gl.deleteFramebuffer(framebuffer);\n    gl.deleteTexture(texture);\n  }};\n};"
        }
      }
    }
  },
  "preventionStrategies": {
    "contextScopeValidation": {
      "preDevChecklist": [
        "All function factories return explicit interfaces",
        "No implicit `this` context dependencies",
        "Async operations use arrow functions or explicit binding",
        "State access through controlled getters only"
      ],
      "moduleTemplate": "export const createModule = (dependencies = {}) => {\n  // Validate dependencies at creation time\n  const { requiredDep } = dependencies;\n  if (!requiredDep) throw new Error('Required dependency missing');\n  \n  // Private state - only accessible through controlled interface\n  const state = { initialized: false };\n  \n  // Controlled access functions\n  const validateInitialized = () => {\n    if (!state.initialized) throw new Error('Module not initialized');\n  };\n  \n  const initialize = async (config = {}) => {\n    // Initialization logic with proper error handling\n    try {\n      // Setup code\n      state.initialized = true;\n      return { success: true };\n    } catch (error) {\n      state.initialized = false;\n      throw new Error(`Initialization failed: ${error.message}`);\n    }\n  };\n  \n  const process = async (input, context = {}) => {\n    validateInitialized();\n    // Processing logic\n  };\n  \n  const cleanup = () => {\n    // Cleanup logic\n    state.initialized = false;\n  };\n  \n  // Explicit interface - no hidden dependencies\n  return {\n    initialize,\n    process, \n    cleanup,\n    isReady: () => state.initialized\n  };\n};"
    },
    "webglContextSafety": {
      "validatorTemplate": "const createWebGLValidator = () => {\n  const validateContext = (gl, contextName = 'WebGL') => {\n    if (!gl) throw new Error(`${contextName} context is null or undefined`);\n    \n    // Check for mock context issues\n    const requiredMethods = ['getExtension', 'createTexture', 'createFramebuffer'];\n    for (const method of requiredMethods) {\n      if (typeof gl[method] !== 'function') {\n        throw new Error(`${contextName} context missing method: ${method}`);\n      }\n    }\n    \n    // Check for context loss\n    if (gl.isContextLost && gl.isContextLost()) {\n      throw new Error(`${contextName} context is lost`);\n    }\n    \n    return true;\n  };\n  \n  const createSafeGetter = (getContextFn, contextName) => {\n    return () => {\n      const context = getContextFn();\n      validateContext(context, contextName);\n      return context;\n    };\n  };\n  \n  return { validateContext, createSafeGetter };\n};"
    },
    "importExportSafety": {
      "rules": [
        "Always use explicit imports: import { specificFunction } from './module.js';",
        "Avoid wildcard imports: import * as module from './module.js'; // RISKY",
        "Validate imports immediately after import",
        "Use dependency injection for complex relationships"
      ],
      "safeImportPattern": "import { requiredFunction } from './dependency.js';\nif (typeof requiredFunction !== 'function') {\n  throw new Error('Invalid import: requiredFunction is not a function');\n}"
    },
    "errorHandlingStandards": {
      "bulletproofTemplate": "export const createErrorHandler = (config = {}) => {\n  const state = {\n    errorCount: 0,\n    maxErrors: config.maxErrors || 100,\n    handlingError: false // Prevent recursive handling\n  };\n  \n  const handleError = (error, context = {}, depth = 0) => {\n    // Prevent infinite recursion\n    if (state.handlingError || depth > 3) {\n      console.error('Error handler recursion detected, falling back to console:', error);\n      return { handled: false, error };\n    }\n    \n    // Prevent error spam\n    if (state.errorCount >= state.maxErrors) {\n      console.error('Too many errors, suppressing further handling:', error);\n      return { handled: false, error };\n    }\n    \n    state.handlingError = true;\n    state.errorCount++;\n    \n    try {\n      // Safe error processing\n      const errorInfo = {\n        message: error.message || 'Unknown error',\n        stack: error.stack || 'No stack trace',\n        context,\n        timestamp: new Date().toISOString()\n      };\n      \n      // Safe logging (with fallback)\n      try {\n        console.error('Handled error:', errorInfo);\n      } catch (loggingError) {\n        console.error('Logging failed:', loggingError, 'Original error:', error);\n      }\n      \n      return { handled: true, error: errorInfo };\n      \n    } catch (handlingError) {\n      console.error('Error handling failed:', handlingError, 'Original error:', error);\n      return { handled: false, error };\n      \n    } finally {\n      state.handlingError = false;\n    }\n  };\n  \n  return { handleError, getStats: () => ({ errorCount: state.errorCount }) };\n};"
    }
  },
  "codeReviewChecklist": {
    "contextScopeSafety": [
      "No function calls to variables that might not be in scope",
      "All closures explicitly capture required dependencies",
      "No implicit `this` context dependencies",
      "Dynamic function calls have explicit error handling"
    ],
    "webglContextSafety": [
      "All WebGL operations validate context first",
      "Environment differences handled (browser vs server)",
      "Resource cleanup paths implemented",
      "Framebuffer completeness checked"
    ],
    "importExportIntegrity": [
      "All imports have corresponding exports",
      "No circular dependency chains",
      "Default vs named exports used consistently",
      "Dynamic imports have error handling"
    ],
    "errorHandlingStandards": [
      "No recursive error handling paths",
      "Error handlers have recursion depth limits",
      "All async operations have catch blocks",
      "Error messages include helpful context"
    ],
    "resourceManagement": [
      "All created resources have cleanup paths",
      "Memory leaks prevented through proper cleanup",
      "State mutations are controlled and validated",
      "Initialization/cleanup order documented"
    ]
  },
  "automatedDetection": {
    "patterns": {
      "scopeViolation": {
        "regex": "function.*\\{[\\s\\S]*?\\b(\\w+)\\b\\([\\s\\S]*?\\}[\\s\\S]*?return[\\s\\S]*?\\{[\\s\\S]*?\\b\\1\\b",
        "description": "Function scope violations and closure issues"
      },
      "missingValidation": {
        "regex": "\\.gl[\\.].*(?!if|try|validateContext)",
        "description": "WebGL operations without proper validation"
      },
      "recursiveError": {
        "regex": "handleError[\\s\\S]*?catch[\\s\\S]*?handleError",
        "description": "Recursive error handling patterns"
      },
      "circularImport": {
        "regex": "import.*from.*\\/.*(?=[\\s\\S]*export.*import.*from.*\\/)",
        "description": "Potential circular dependency patterns"
      },
      "resourceLeak": {
        "regex": "create(?:Framebuffer|Texture|Buffer).*(?!delete)",
        "description": "WebGL resources without cleanup"
      }
    },
    "validationFunction": "const validateCodeSafety = (sourceCode) => {\n  const risks = [];\n  \n  for (const [pattern, config] of Object.entries(patterns)) {\n    const regex = new RegExp(config.regex);\n    if (regex.test(sourceCode)) {\n      risks.push({\n        pattern,\n        description: config.description,\n        severity: getSeverityForPattern(pattern)\n      });\n    }\n  }\n  \n  return risks;\n};"
  },
  "developmentWorkflow": {
    "phaseDesign": [
      "Dependency Mapping - List all external dependencies",
      "Context Analysis - Identify all variable scopes and lifetimes",
      "Error Scenarios - Plan failure modes and recovery paths",
      "Resource Planning - Document creation/cleanup pairs"
    ],
    "phaseImplementation": [
      "Pattern Adherence - Use approved patterns from this guide",
      "Incremental Testing - Test each function independently",
      "Context Validation - Add validation for all external dependencies",
      "Error Path Testing - Explicitly test failure scenarios"
    ],
    "phaseValidation": [
      "Static Analysis - Run automated bug detection",
      "Integration Testing - Test module interactions",
      "Resource Auditing - Verify all cleanup paths",
      "Error Injection - Test with induced failures"
    ]
  },
  "status": {
    "documentStatus": "COMPLETE",
    "nextAction": "Apply framework to conduct targeted re-audit of existing code"
  }
}