<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaPipe WebRTC Demo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }
        
        h1 {
            text-align: center;
            color: #4CAF50;
            margin-bottom: 30px;
            font-size: 2.2em;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(145deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .video-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .video-container {
            position: relative;
            background: #2a2a2a;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
        }
        
        .video-header {
            background: linear-gradient(90deg, #333, #444);
            padding: 10px 15px;
            font-weight: bold;
            font-size: 14px;
            border-bottom: 2px solid #4CAF50;
        }
        
        video {
            width: 100%;
            height: auto;
            max-width: 640px;
            max-height: 480px;
            background: #000;
            display: block;
        }
        
        canvas {
            position: absolute;
            top: 40px;
            left: 0;
            pointer-events: none;
            width: 100%;
            height: calc(100% - 40px);
        }
        
        .status-panel {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }
        
        .status-item {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }
        
        .status-label {
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 5px;
        }
        
        .status-value {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #e0e0e0;
        }
        
        .connection-id {
            background: #1a1a1a;
            padding: 10px 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-top: 10px;
            border: 1px solid #444;
            text-align: center;
        }
        
        @media (max-width: 768px) {
            .video-grid {
                grid-template-columns: 1fr;
            }
            .status-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé≠ MediaPipe Face Mesh WebRTC Demo</h1>
        
        <div class="controls">
            <button id="startBtn">üìπ Start Camera</button>
            <button id="streamBtn" disabled>üì° Start Streaming</button>
            <button id="receiveBtn" disabled>üì• Receive Stream</button>
            <button id="stopBtn" disabled>‚èπÔ∏è Stop</button>
        </div>
        
        <div class="video-grid">
            <div class="video-container">
                <div class="video-header">üìπ Local Video (You)</div>
                <video id="localVideo" autoplay muted playsinline></video>
                <canvas id="localCanvas"></canvas>
            </div>
            
            <div class="video-container">
                <div class="video-header">üåê Remote Video (Peer)</div>
                <video id="remoteVideo" autoplay playsinline></video>
                <canvas id="remoteCanvas"></canvas>
            </div>
        </div>
        
        <div class="status-panel">
            <div class="status-grid">
                <div class="status-item">
                    <div class="status-label">Connection Status</div>
                    <div class="status-value" id="connectionStatus">Initializing...</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Face Detection</div>
                    <div class="status-value" id="faceStatus">Ready</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Data Channel</div>
                    <div class="status-value" id="dataStatus">Closed</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Performance</div>
                    <div class="status-value" id="perfStatus">0 FPS</div>
                </div>
            </div>
            <div class="connection-id" id="connectionId">Connection ID: Not connected</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

    <script>
        // DOM Elements
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const localCanvas = document.getElementById('localCanvas');
        const remoteCanvas = document.getElementById('remoteCanvas');
        
        const startBtn = document.getElementById('startBtn');
        const streamBtn = document.getElementById('streamBtn');
        const receiveBtn = document.getElementById('receiveBtn');
        const stopBtn = document.getElementById('stopBtn');
        
        const connectionStatus = document.getElementById('connectionStatus');
        const faceStatus = document.getElementById('faceStatus');
        const dataStatus = document.getElementById('dataStatus');
        const perfStatus = document.getElementById('perfStatus');
        const connectionId = document.getElementById('connectionId');
        
        // Application State
        let faceMesh = null;
        let localCtx = null;
        let remoteCtx = null;
        let isRunning = false;
        let isStreaming = false;
        let localStream = null;
        let peerConnection = null;
        let dataChannel = null;
        let frameCount = 0;
        let lastFrameTime = Date.now();
        
        // Utility functions
        const updateStatus = (element, message, isError = false) => {
            element.textContent = message;
            element.style.color = isError ? '#ff4444' : '#e0e0e0';
            console.log(message);
        };
        
        const updatePerformance = () => {
            frameCount++;
            const now = Date.now();
            if (now - lastFrameTime >= 1000) {
                const fps = Math.round((frameCount * 1000) / (now - lastFrameTime));
                updateStatus(perfStatus, `${fps} FPS | ${frameCount} frames`);
                frameCount = 0;
                lastFrameTime = now;
            }
        };
        
        // MediaPipe initialization
        async function initMediaPipe() {
            try {
                updateStatus(connectionStatus, 'Initializing MediaPipe...');
                
                faceMesh = new FaceMesh({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
                });
                
                faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                faceMesh.onResults(onLocalResults);
                await faceMesh.initialize();
                
                updateStatus(connectionStatus, 'Ready - Click Start Camera');
                updateStatus(faceStatus, 'MediaPipe initialized');
                
            } catch (error) {
                updateStatus(connectionStatus, 'MediaPipe init failed: ' + error.message, true);
            }
        }
        
        // Face detection results handler
        function onLocalResults(results) {
            const faceCount = results.multiFaceLandmarks?.length || 0;
            updateStatus(faceStatus, faceCount > 0 ? `${faceCount} face(s) detected` : 'No faces detected');
            
            if (!localCtx) return;
            
            // Clear and redraw
            localCtx.clearRect(0, 0, localCanvas.width, localCanvas.height);
            
            // Draw faces
            if (results.multiFaceLandmarks) {
                drawFaceMesh(localCtx, results.multiFaceLandmarks);
                
                // Send face data via WebRTC if streaming
                if (isStreaming && dataChannel && dataChannel.readyState === 'open') {
                    try {
                        const faceData = {
                            type: 'face_landmarks',
                            timestamp: Date.now(),
                            landmarks: results.multiFaceLandmarks
                        };
                        dataChannel.send(JSON.stringify(faceData));
                    } catch (error) {
                        console.error('Error sending face data:', error);
                    }
                }
            }
            
            updatePerformance();
        }
        
        // Face mesh drawing
        function drawFaceMesh(ctx, faceLandmarks) {
            ctx.fillStyle = '#00FF00';
            ctx.strokeStyle = '#00FFFF';
            ctx.lineWidth = 1;
            
            // Get the video element dimensions for proper scaling
            const video = localVideo;
            const scaleX = ctx.canvas.width / video.videoWidth;
            const scaleY = ctx.canvas.height / video.videoHeight;
            
            faceLandmarks.forEach(landmarks => {
                // Draw all landmarks with proper scaling
                landmarks.forEach(landmark => {
                    const x = landmark.x * video.videoWidth * scaleX;
                    const y = landmark.y * video.videoHeight * scaleY;
                    ctx.beginPath();
                    ctx.arc(x, y, 1, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // Draw face outline
                if (landmarks.length >= 468) {
                    const faceOutline = [
                        10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 
                        397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 
                        172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109
                    ];
                    
                    ctx.beginPath();
                    faceOutline.forEach((index, i) => {
                        if (landmarks[index]) {
                            const x = landmarks[index].x * video.videoWidth * scaleX;
                            const y = landmarks[index].y * video.videoHeight * scaleY;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                    });
                    ctx.closePath();
                    ctx.stroke();
                }
            });
        }
        
        // Camera start
        async function startCamera() {
            try {
                updateStatus(connectionStatus, 'Starting camera...');
                startBtn.disabled = true;
                
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' },
                    audio: true
                });
                
                localVideo.srcObject = localStream;
                
                localVideo.addEventListener('loadedmetadata', () => {
                    const setupCanvas = () => {
                        const videoRect = localVideo.getBoundingClientRect();
                        
                        // Set canvas resolution to match actual video display size
                        localCanvas.width = videoRect.width;
                        localCanvas.height = videoRect.height - 40;
                        
                        if (!localCtx) {
                            localCtx = localCanvas.getContext('2d');
                        }
                        
                        console.log('Canvas setup:', {
                            videoActual: `${localVideo.videoWidth}x${localVideo.videoHeight}`,
                            videoDisplay: `${videoRect.width}x${videoRect.height}`,
                            canvasSize: `${localCanvas.width}x${localCanvas.height}`
                        });
                    };
                    
                    // Initial setup with longer delay for Firefox layout
                    setTimeout(() => {
                        setupCanvas();
                        
                        updateStatus(connectionStatus, 'Camera started - Processing faces');
                        isRunning = true;
                        streamBtn.disabled = false;
                        receiveBtn.disabled = false;
                        stopBtn.disabled = false;
                        
                        processLocalVideo();
                    }, 300);
                    
                    // Setup resize handler to fix alignment on window resize
                    const resizeHandler = () => {
                        if (isRunning) {
                            setupCanvas();
                        }
                    };
                    
                    // Remove previous listeners and add new one
                    window.removeEventListener('resize', resizeHandler);
                    window.addEventListener('resize', resizeHandler);
                });
                
            } catch (error) {
                updateStatus(connectionStatus, 'Camera failed: ' + error.message, true);
                startBtn.disabled = false;
            }
        }
        
        // Video processing loop
        async function processLocalVideo() {
            if (!isRunning) return;
            
            try {
                await faceMesh.send({ image: localVideo });
            } catch (error) {
                console.error('Process error:', error);
            }
            
            requestAnimationFrame(processLocalVideo);
        }
        
        // WebSocket connection for signaling
        let signalWs = null;
        let sessionId = null;
        
        const connectToSignalServer = () => {
            const wsUrl = `ws://localhost:8081/ws`;
            signalWs = new WebSocket(wsUrl);
            
            signalWs.onopen = () => {
                console.log('Connected to signaling server');
                updateStatus(dataStatus, 'Signaling connected');
                
                // Send configuration to establish session
                sendSignalMessage({
                    type: 'configure',
                    requirements: { webrtc: true }
                });
            };
            
            signalWs.onmessage = (event) => {
                const message = JSON.parse(event.data);
                console.log('üì® Received WebSocket message:', message);
                handleSignalMessage(message);
            };
            
            signalWs.onclose = () => {
                console.log('Signaling server disconnected');
                updateStatus(dataStatus, 'Signaling disconnected');
            };
            
            signalWs.onerror = (error) => {
                console.error('Signaling error:', error);
                updateStatus(dataStatus, 'Signaling error', true);
            };
        };
        
        const sendSignalMessage = (message) => {
            if (signalWs && signalWs.readyState === WebSocket.OPEN) {
                const fullMessage = { 
                    ...message, 
                    deviceId: sessionId || 'unknown',
                    timestamp: Date.now()
                };
                console.log('üì§ Sending WebSocket message:', fullMessage);
                signalWs.send(JSON.stringify(fullMessage));
            } else {
                console.warn('‚ö†Ô∏è Cannot send message - WebSocket not ready');
            }
        };
        
        const handleSignalMessage = (message) => {
            console.log('üì® Received WebSocket message:', message);
            
            switch (message.type) {
                case 'configured':
                    sessionId = message.sessionId;
                    updateStatus(connectionId, `Session ID: ${sessionId}`);
                    break;
                    
                case 'stream_started':
                    console.log('üì® Stream started from:', message.deviceId);
                    break;
                    
                case 'stream_stopped':
                    console.log('üì® Stream stopped from:', message.deviceId);
                    break;
                    
                case 'request_offer':
                    console.log('üì® Received request_offer, isStreaming:', isStreaming);
                    if (isStreaming && peerConnection) {
                        sendOfferToReceiver();
                    }
                    break;
                    
                case 'webrtc_offer':
                    console.log('üì® Received WebRTC offer');
                    if (message.sdp) {
                        handleRemoteOffer(message.sdp);
                    }
                    break;
                    
                case 'webrtc_answer':
                    console.log('üì® Received WebRTC answer');
                    if (message.sdp) {
                        handleRemoteAnswer(message.sdp);
                    }
                    break;
                    
                case 'webrtc_ice':
                    console.log('üì® Received ICE candidate');
                    if (message.candidate) {
                        handleRemoteIceCandidate(message.candidate);
                    }
                    break;
                    
                case 'error':
                    console.error('Signaling error:', message.error);
                    break;
                    
                default:
                    console.log('Unknown message type:', message.type);
            }
        };
        
        // Start streaming (broadcaster)
        async function startStreaming() {
            if (isStreaming) {
                // Stop streaming
                stopStreaming();
                return;
            }
            
            try {
                updateStatus(connectionStatus, 'Setting up streaming...');
                streamBtn.disabled = true;
                
                // Connect to signaling server
                if (!signalWs || signalWs.readyState !== WebSocket.OPEN) {
                    connectToSignalServer();
                    await new Promise(resolve => {
                        const checkConnection = () => {
                            if (signalWs?.readyState === WebSocket.OPEN) {
                                resolve();
                            } else {
                                setTimeout(checkConnection, 100);
                            }
                        };
                        checkConnection();
                    });
                }
                
                // Create peer connection
                const configuration = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                };
                
                peerConnection = new RTCPeerConnection(configuration);
                
                // Add local stream tracks
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
                
                // Create data channel for face landmarks
                dataChannel = peerConnection.createDataChannel('faceData', { 
                    ordered: true 
                });
                
                dataChannel.onopen = () => {
                    updateStatus(dataStatus, 'Face data channel open');
                    isStreaming = true;
                    streamBtn.textContent = '‚èπÔ∏è Stop Streaming';
                    streamBtn.disabled = false;
                };
                
                // Handle ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        sendSignalMessage({
                            type: 'webrtc_ice',
                            candidate: event.candidate
                        });
                    }
                };
                
                // Monitor connection state
                peerConnection.onconnectionstatechange = () => {
                    updateStatus(connectionStatus, `WebRTC: ${peerConnection.connectionState}`);
                };
                
                updateStatus(connectionStatus, 'Ready to stream - waiting for receivers');
                updateStatus(connectionId, `Broadcasting as: ${sessionId}`);
                
            } catch (error) {
                updateStatus(connectionStatus, 'Streaming setup failed: ' + error.message, true);
                streamBtn.disabled = false;
            }
        }
        
        // Receive stream (receiver)
        async function receiveStream() {
            try {
                updateStatus(connectionStatus, 'Setting up to receive stream...');
                receiveBtn.disabled = true;
                
                // Connect to signaling server
                if (!signalWs || signalWs.readyState !== WebSocket.OPEN) {
                    connectToSignalServer();
                    await new Promise(resolve => {
                        const checkConnection = () => {
                            if (signalWs?.readyState === WebSocket.OPEN) {
                                resolve();
                            } else {
                                setTimeout(checkConnection, 100);
                            }
                        };
                        checkConnection();
                    });
                }
                
                // Create peer connection for receiving
                const configuration = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                };
                
                peerConnection = new RTCPeerConnection(configuration);
                
                // Handle incoming data channel
                peerConnection.ondatachannel = (event) => {
                    const channel = event.channel;
                    channel.onopen = () => {
                        updateStatus(dataStatus, 'Receiving face data');
                    };
                    
                    channel.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            if (data.type === 'face_landmarks') {
                                renderRemoteFaces(data.landmarks);
                            }
                        } catch (error) {
                            console.error('Error parsing face data:', error);
                        }
                    };
                };
                
                // Handle incoming stream
                peerConnection.ontrack = (event) => {
                    console.log('Received remote stream');
                    remoteVideo.srcObject = event.streams[0];
                    
                    remoteVideo.addEventListener('loadedmetadata', () => {
                        const videoRect = remoteVideo.getBoundingClientRect();
                        remoteCanvas.width = videoRect.width;
                        remoteCanvas.height = videoRect.height - 40;
                        remoteCtx = remoteCanvas.getContext('2d');
                        updateStatus(connectionStatus, 'Receiving stream and face data');
                    });
                };
                
                // Handle ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        sendSignalMessage({
                            type: 'webrtc_ice',
                            candidate: event.candidate
                        });
                    }
                };
                
                sendSignalMessage({
                    type: 'request_offer'
                });
                
                updateStatus(connectionStatus, 'Waiting for stream...');
                receiveBtn.textContent = '‚è≥ Waiting for Stream';
                
            } catch (error) {
                updateStatus(connectionStatus, 'Receive setup failed: ' + error.message, true);
                receiveBtn.disabled = false;
            }
        }
        
        // Handle remote offer (receiver side)
        const handleRemoteOffer = async (offer) => {
            try {
                await peerConnection.setRemoteDescription(offer);
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                sendSignalMessage({
                    type: 'webrtc_answer',
                    sdp: answer
                });
                
            } catch (error) {
                console.error('Error handling remote offer:', error);
            }
        };
        
        // Handle remote answer (broadcaster side)
        const handleRemoteAnswer = async (answer) => {
            try {
                await peerConnection.setRemoteDescription(answer);
            } catch (error) {
                console.error('Error handling remote answer:', error);
            }
        };
        
        // Handle ICE candidate
        const handleRemoteIceCandidate = async (candidate) => {
            try {
                await peerConnection.addIceCandidate(candidate);
            } catch (error) {
                console.error('Error adding ICE candidate:', error);
            }
        };
        
        // Stop streaming
        const stopStreaming = () => {
            isStreaming = false;
            streamBtn.textContent = 'üì° Start Streaming';
            streamBtn.disabled = false;
            
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            updateStatus(connectionStatus, 'Streaming stopped');
            updateStatus(dataStatus, 'Disconnected');
        }
        
        // Send offer to receiver (when requested)
        const sendOfferToReceiver = async () => {
            try {
                console.log('Creating offer for receiver...');
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                sendSignalMessage({
                    type: 'webrtc_offer',
                    sdp: offer
                });
                
                updateStatus(connectionStatus, 'Offer sent to receiver');
                
            } catch (error) {
                console.error('Error sending offer:', error);
            }
        };
        
        
        // Render remote faces
        function renderRemoteFaces(faceLandmarks) {
            if (!remoteCtx) return;
            
            remoteCtx.clearRect(0, 0, remoteCanvas.width, remoteCanvas.height);
            drawFaceMesh(remoteCtx, faceLandmarks);
        }
        
        // Stop everything
        function stop() {
            isRunning = false;
            isStreaming = false;
            
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            
            if (signalWs) {
                signalWs.close();
                signalWs = null;
            }
            
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            
            if (localCtx) localCtx.clearRect(0, 0, localCanvas.width, localCanvas.height);
            if (remoteCtx) remoteCtx.clearRect(0, 0, remoteCanvas.width, remoteCanvas.height);
            
            startBtn.disabled = false;
            streamBtn.disabled = true;
            streamBtn.textContent = 'üì° Start Streaming';
            receiveBtn.disabled = true;
            receiveBtn.textContent = 'üì• Receive Stream';
            stopBtn.disabled = true;
            
            updateStatus(connectionStatus, 'Stopped');
            updateStatus(faceStatus, 'Ready');
            updateStatus(dataStatus, 'Disconnected');
            updateStatus(perfStatus, '0 FPS');
            updateStatus(connectionId, 'Not connected');
        }
        
        // Event listeners
        startBtn.addEventListener('click', startCamera);
        streamBtn.addEventListener('click', startStreaming);
        receiveBtn.addEventListener('click', receiveStream);
        stopBtn.addEventListener('click', stop);
        
        // Initialize on page load
        function checkReady() {
            if (typeof FaceMesh !== 'undefined') {
                initMediaPipe().then(() => {
                    // Auto-start camera after MediaPipe is ready
                    setTimeout(() => {
                        if (!isRunning) {
                            startCamera();
                        }
                    }, 500);
                });
            } else {
                setTimeout(checkReady, 100);
            }
        }
        checkReady();
    </script>
</body>
</html>